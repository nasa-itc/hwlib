/* Copyright (C) 2009 - 2017 National Aeronautics and Space Administration. All Foreign Rights are Reserved to the U.S. Government.

This software is provided "as is" without any warranty of any, kind either express, implied, or statutory, including, but not
limited to, any warranty that the software will conform to, specifications any implied warranties of merchantability, fitness
for a particular purpose, and freedom from infringement, and any warranty that the documentation will conform to the program, or
any warranty that the software will be error free.

In no event shall NASA be liable for any damages, including, but not limited to direct, indirect, special or consequential damages,
arising out of, resulting from, or in any way connected with the software or its documentation.  Whether or not based upon warranty,
contract, tort or otherwise, and whether or not loss was sustained from, or arose out of the results of, or use of, the software,
documentation or services provided hereunder

ITC Team
NASA IV&V
ivv-itc@lists.nasa.gov
*/

/*******************************************************************************
**
** Reference: https://github.com/ArduCAM
**
*******************************************************************************/

/*************************************************************************
** Includes
*************************************************************************/
#include "osapi.h"
#include "hwlib.h"
#include "cam_lib.h"

/*************************************************************************
** Includes for NOS 
*************************************************************************/
#include "libi2c.h"
#include "libspi.h"

/*************************************************************************
** Global Data 
*************************************************************************/
spi_info_t CAM_SPI;

/*************************************************************************
** Hardware Registers 
*************************************************************************/
#ifdef OV2640
static struct sensor_reg OV2640_JPEG_INIT[] =
{
  { 0xff, 0x00 },
  { 0x2c, 0xff },
  { 0x2e, 0xdf },
  { 0xff, 0x01 },
  { 0x3c, 0x32 },
  { 0x11, 0x00 },	
  { 0x09, 0x02 },
  { 0x04, 0x28 },
  { 0x13, 0xe5 },
  { 0x14, 0x48 },
  { 0x2c, 0x0c },
  { 0x33, 0x78 },
  { 0x3a, 0x33 },
  { 0x3b, 0xfB },
  { 0x3e, 0x00 },
  { 0x43, 0x11 },
  { 0x16, 0x10 },
  { 0x39, 0x92 },
  { 0x35, 0xda },
  { 0x22, 0x1a },
  { 0x37, 0xc3 },
  { 0x23, 0x00 },
  { 0x34, 0xc0 },
  { 0x36, 0x1a },
  { 0x06, 0x88 },
  { 0x07, 0xc0 },
  { 0x0d, 0x87 },
  { 0x0e, 0x41 },
  { 0x4c, 0x00 },
  { 0x48, 0x00 },
  { 0x5B, 0x00 },
  { 0x42, 0x03 },
  { 0x4a, 0x81 },
  { 0x21, 0x99 },
  { 0x24, 0x40 },
  { 0x25, 0x38 },
  { 0x26, 0x82 },
  { 0x5c, 0x00 },
  { 0x63, 0x00 },
  { 0x61, 0x70 },
  { 0x62, 0x80 },
  { 0x7c, 0x05 },
  { 0x20, 0x80 },
  { 0x28, 0x30 },
  { 0x6c, 0x00 },
  { 0x6d, 0x80 },
  { 0x6e, 0x00 },
  { 0x70, 0x02 },
  { 0x71, 0x94 },
  { 0x73, 0xc1 },
  { 0x12, 0x40 },
  { 0x17, 0x11 },
  { 0x18, 0x43 },
  { 0x19, 0x00 },
  { 0x1a, 0x4b },
  { 0x32, 0x09 },
  { 0x37, 0xc0 },
  { 0x4f, 0x60 },
  { 0x50, 0xa8 },
  { 0x6d, 0x00 },
  { 0x3d, 0x38 },
  { 0x46, 0x3f },
  { 0x4f, 0x60 },
  { 0x0c, 0x3c },
  { 0xff, 0x00 },
  { 0xe5, 0x7f },
  { 0xf9, 0xc0 },
  { 0x41, 0x24 },
  { 0xe0, 0x14 },
  { 0x76, 0xff },
  { 0x33, 0xa0 },
  { 0x42, 0x20 },
  { 0x43, 0x18 },
  { 0x4c, 0x00 },
  { 0x87, 0xd5 },
  { 0x88, 0x3f },
  { 0xd7, 0x03 },
  { 0xd9, 0x10 },
  { 0xd3, 0x82 },
  { 0xc8, 0x08 },
  { 0xc9, 0x80 },
  { 0x7c, 0x00 },
  { 0x7d, 0x00 },
  { 0x7c, 0x03 },
  { 0x7d, 0x48 },
  { 0x7d, 0x48 },
  { 0x7c, 0x08 },
  { 0x7d, 0x20 },
  { 0x7d, 0x10 },
  { 0x7d, 0x0e },
  { 0x90, 0x00 },
  { 0x91, 0x0e },
  { 0x91, 0x1a },
  { 0x91, 0x31 },
  { 0x91, 0x5a },
  { 0x91, 0x69 },
  { 0x91, 0x75 },
  { 0x91, 0x7e },
  { 0x91, 0x88 },
  { 0x91, 0x8f },
  { 0x91, 0x96 },
  { 0x91, 0xa3 },
  { 0x91, 0xaf },
  { 0x91, 0xc4 },
  { 0x91, 0xd7 },
  { 0x91, 0xe8 },
  { 0x91, 0x20 },
  { 0x92, 0x00 },
  { 0x93, 0x06 },
  { 0x93, 0xe3 },
  { 0x93, 0x05 },
  { 0x93, 0x05 },
  { 0x93, 0x00 },
  { 0x93, 0x04 },
  { 0x93, 0x00 },
  { 0x93, 0x00 },
  { 0x93, 0x00 },
  { 0x93, 0x00 },
  { 0x93, 0x00 },
  { 0x93, 0x00 },
  { 0x93, 0x00 },
  { 0x96, 0x00 },
  { 0x97, 0x08 },
  { 0x97, 0x19 },
  { 0x97, 0x02 },
  { 0x97, 0x0c },
  { 0x97, 0x24 },
  { 0x97, 0x30 },
  { 0x97, 0x28 },
  { 0x97, 0x26 },
  { 0x97, 0x02 },
  { 0x97, 0x98 },
  { 0x97, 0x80 },
  { 0x97, 0x00 },
  { 0x97, 0x00 },
  { 0xc3, 0xed },
  { 0xa4, 0x00 },
  { 0xa8, 0x00 },
  { 0xc5, 0x11 },
  { 0xc6, 0x51 },
  { 0xbf, 0x80 },
  { 0xc7, 0x10 },
  { 0xb6, 0x66 },
  { 0xb8, 0xA5 },
  { 0xb7, 0x64 },
  { 0xb9, 0x7C },
  { 0xb3, 0xaf },
  { 0xb4, 0x97 },
  { 0xb5, 0xFF },
  { 0xb0, 0xC5 },
  { 0xb1, 0x94 },
  { 0xb2, 0x0f },
  { 0xc4, 0x5c },
  { 0xc0, 0x64 },
  { 0xc1, 0x4B },
  { 0x8c, 0x00 },
  { 0x86, 0x3D },
  { 0x50, 0x00 },
  { 0x51, 0xC8 },
  { 0x52, 0x96 },
  { 0x53, 0x00 },
  { 0x54, 0x00 },
  { 0x55, 0x00 },
  { 0x5a, 0xC8 },
  { 0x5b, 0x96 },
  { 0x5c, 0x00 },
  { 0xd3, 0x00 },	//{ 0xd3, 0x7f },
  { 0xc3, 0xed },
  { 0x7f, 0x00 },
  { 0xda, 0x00 },
  { 0xe5, 0x1f },
  { 0xe1, 0x67 },
  { 0xe0, 0x00 },
  { 0xdd, 0x7f },
  { 0x05, 0x00 },
               
  { 0x12, 0x40 },
  { 0xd3, 0x04 },	//{ 0xd3, 0x7f },
  { 0xc0, 0x16 },
  { 0xC1, 0x12 },
  { 0x8c, 0x00 },
  { 0x86, 0x3d },
  { 0x50, 0x00 },
  { 0x51, 0x2C },
  { 0x52, 0x24 },
  { 0x53, 0x00 },
  { 0x54, 0x00 },
  { 0x55, 0x00 },
  { 0x5A, 0x2c },
  { 0x5b, 0x24 },
  { 0x5c, 0x00 },
  { 0xFF, 0xFF },
};             

static struct sensor_reg OV2640_YUV422[] =
{
  { 0xFF, 0x00 },
  { 0x05, 0x00 },
  { 0xDA, 0x10 },
  { 0xD7, 0x03 },
  { 0xDF, 0x00 },
  { 0x33, 0x80 },
  { 0x3C, 0x40 },
  { 0xe1, 0x77 },
  { 0x00, 0x00 },
  { 0xFF, 0xFF },
};

static struct sensor_reg OV2640_JPEG[] =  
{
  { 0xe0, 0x14 },
  { 0xe1, 0x77 },
  { 0xe5, 0x1f },
  { 0xd7, 0x03 },
  { 0xda, 0x10 },
  { 0xe0, 0x00 },
  { 0xFF, 0x01 },
  { 0x04, 0x08 },
  { 0xFF, 0xFF },
}; 

static struct sensor_reg OV2640_160x120_JPEG[] =  
{
  { 0xff, 0x01 },
  { 0x12, 0x40 },
  { 0x17, 0x11 },
  { 0x18, 0x43 },
  { 0x19, 0x00 },
  { 0x1a, 0x4b },
  { 0x32, 0x09 },
  { 0x4f, 0xca },
  { 0x50, 0xa8 },
  { 0x5a, 0x23 },
  { 0x6d, 0x00 },
  { 0x39, 0x12 },
  { 0x35, 0xda },
  { 0x22, 0x1a },
  { 0x37, 0xc3 },
  { 0x23, 0x00 },
  { 0x34, 0xc0 },
  { 0x36, 0x1a },
  { 0x06, 0x88 },
  { 0x07, 0xc0 },
  { 0x0d, 0x87 },
  { 0x0e, 0x41 },
  { 0x4c, 0x00 },
  { 0xff, 0x00 },
  { 0xe0, 0x04 },
  { 0xc0, 0x64 },
  { 0xc1, 0x4b },
  { 0x86, 0x35 },
  { 0x50, 0x92 },
  { 0x51, 0xc8 },
  { 0x52, 0x96 },
  { 0x53, 0x00 },
  { 0x54, 0x00 },
  { 0x55, 0x00 },
  { 0x57, 0x00 },
  { 0x5a, 0x28 },
  { 0x5b, 0x1e },
  { 0x5c, 0x00 },
  { 0xe0, 0x00 },
  { 0xFF, 0xFF },
};

static struct sensor_reg OV2640_320x240_JPEG[] =  
{
  { 0xff, 0x01 },
  { 0x12, 0x40 },
  { 0x17, 0x11 },
  { 0x18, 0x43 },
  { 0x19, 0x00 },
  { 0x1a, 0x4b },
  { 0x32, 0x09 },
  { 0x4f, 0xca },
  { 0x50, 0xa8 },
  { 0x5a, 0x23 },
  { 0x6d, 0x00 },
  { 0x39, 0x12 },
  { 0x35, 0xda },
  { 0x22, 0x1a },
  { 0x37, 0xc3 },
  { 0x23, 0x00 },
  { 0x34, 0xc0 },
  { 0x36, 0x1a },
  { 0x06, 0x88 },
  { 0x07, 0xc0 },
  { 0x0d, 0x87 },
  { 0x0e, 0x41 },
  { 0x4c, 0x00 },
  { 0xff, 0x00 },
  { 0xe0, 0x04 },
  { 0xc0, 0x64 },
  { 0xc1, 0x4b },
  { 0x86, 0x35 },
  { 0x50, 0x89 },
  { 0x51, 0xc8 },
  { 0x52, 0x96 },
  { 0x53, 0x00 },
  { 0x54, 0x00 },
  { 0x55, 0x00 },
  { 0x57, 0x00 },
  { 0x5a, 0x50 },
  { 0x5b, 0x3c },
  { 0x5c, 0x00 },
  { 0xe0, 0x00 },
  { 0xFF, 0xFF },
};

static struct sensor_reg OV2640_800x600_JPEG[] =  
{
    {0xff, 0x01},
    {0x11, 0x01},
    {0x12, 0x00}, // Bit[6:4]: Resolution selection
    {0x17, 0x11}, // HREFST[10:3]
    {0x18, 0x75}, // HREFEND[10:3]
    {0x32, 0x36}, // Bit[5:3]: HREFEND[2:0]; Bit[2:0]: HREFST[2:0]
    {0x19, 0x01}, // VSTRT[9:2]
    {0x1a, 0x97}, // VEND[9:2]
    {0x03, 0x0f}, // Bit[3:2]: VEND[1:0]; Bit[1:0]: VSTRT[1:0]
    {0x37, 0x40},
    {0x4f, 0xbb},
    {0x50, 0x9c},
    {0x5a, 0x57},
    {0x6d, 0x80},
    {0x3d, 0x34},
    {0x39, 0x02},
    {0x35, 0x88},
    {0x22, 0x0a},
    {0x37, 0x40},
    {0x34, 0xa0},
    {0x06, 0x02},
    {0x0d, 0xb7},
    {0x0e, 0x01},
    
    {0xff, 0x00},
    {0xe0, 0x04},
    {0xc0, 0xc8},
    {0xc1, 0x96},
    {0x86, 0x35},
    {0x50, 0x89},
    {0x51, 0x90},
    {0x52, 0x2c},
    {0x53, 0x00},
    {0x54, 0x00},
    {0x55, 0x88},
    {0x57, 0x00},
    {0x5a, 0xc8},
    {0x5b, 0x96},
    {0x5c, 0x00},
    {0xd3, 0x02},
    {0xe0, 0x00},
                      
      {0xFF, 0xFF},
};     
 
static struct sensor_reg OV2640_1600x1200_JPEG[] =  
{
    {0xff, 0x01},
    {0x11, 0x01},
    {0x12, 0x00}, // Bit[6:4]: Resolution selection
    {0x17, 0x11}, // HREFST[10:3]
    {0x18, 0x75}, // HREFEND[10:3]
    {0x32, 0x36}, // Bit[5:3]: HREFEND[2:0]; Bit[2:0]: HREFST[2:0]
    {0x19, 0x01}, // VSTRT[9:2]
    {0x1a, 0x97}, // VEND[9:2]
    {0x03, 0x0f}, // Bit[3:2]: VEND[1:0]; Bit[1:0]: VSTRT[1:0]
    {0x37, 0x40},
    {0x4f, 0xbb},
    {0x50, 0x9c},
    {0x5a, 0x57},
    {0x6d, 0x80},
    {0x3d, 0x34},
    {0x39, 0x02},
    {0x35, 0x88},
    {0x22, 0x0a},
    {0x37, 0x40},
    {0x34, 0xa0},
    {0x06, 0x02},
    {0x0d, 0xb7},
    {0x0e, 0x01},
    
    {0xff, 0x00},        	                              
    {0xe0, 0x04},                                   
    {0xc0, 0xc8},                                   
    {0xc1, 0x96},                                   
    {0x86, 0x3d},                                   
    {0x50, 0x00},                                   
    {0x51, 0x90},                                   
    {0x52, 0x2c},                                   
    {0x53, 0x00},                                   
    {0x54, 0x00},                                   
    {0x55, 0x88},                                   
    {0x57, 0x00},                                   
    {0x5a, 0x90},                                   
    {0x5b, 0x2C},                                   
    {0x5c, 0x05},   //bit2->1;bit[1:0]->1
    {0xd3, 0x02},                                   
    {0xe0, 0x00},                                   
                      
    {0xFF, 0xFF},
};  
#endif

#ifdef OV5640
static struct sensor_reg OV5640YUV_Sensor_Dvp_Init[] =
{
    { 0x4740, 0x20 },
    
    { 0x4050, 0x6e },
    { 0x4051, 0x8f },
    
    { 0x3008, 0x42 }, 
    { 0x3103, 0x03 }, 
    { 0x3017, 0x7f }, 
    { 0x3018, 0xff }, 		
    { 0x302c, 0x02 }, 		
    { 0x3108, 0x01 }, 	
    { 0x3630, 0x2e },//2e
    { 0x3632, 0xe2 }, 
    { 0x3633, 0x23 },//23 
    { 0x3621, 0xe0 }, 
    { 0x3704, 0xa0 }, 
    { 0x3703, 0x5a }, 
    { 0x3715, 0x78 }, 
    { 0x3717, 0x01 }, 
    { 0x370b, 0x60 }, 
    { 0x3705, 0x1a }, 
    { 0x3905, 0x02 }, 
    { 0x3906, 0x10 }, 
    { 0x3901, 0x0a }, 
    { 0x3731, 0x12 }, 
    { 0x3600, 0x08 }, 
    { 0x3601, 0x33 }, 
    { 0x302d, 0x60 }, 
    { 0x3620, 0x52 }, 
    { 0x371b, 0x20 }, 
    { 0x471c, 0x50 }, 
    
    { 0x3a18, 0x00 }, 
    { 0x3a19, 0xf8 }, 
    
    { 0x3635, 0x1c },//1c
    { 0x3634, 0x40 }, 
    { 0x3622, 0x01 }, 

    { 0x3c04, 0x28 }, 
    { 0x3c05, 0x98 }, 
    { 0x3c06, 0x00 }, 
    { 0x3c07, 0x08 }, 
    { 0x3c08, 0x00 }, 
    { 0x3c09, 0x1c }, 
    { 0x3c0a, 0x9c }, 
    { 0x3c0b, 0x40 },  		

    { 0x3820, 0x41 }, 
    { 0x3821, 0x01 }, //07

    //windows setup
    { 0x3800, 0x00 }, 
    { 0x3801, 0x00 }, 
    { 0x3802, 0x00 }, 
    { 0x3803, 0x04 }, 
    { 0x3804, 0x0a }, 
    { 0x3805, 0x3f }, 
    { 0x3806, 0x07 }, 
    { 0x3807, 0x9b }, 
    { 0x3808, 0x05 },  
    { 0x3809, 0x00 }, 
    { 0x380a, 0x03 }, 
    { 0x380b, 0xc0 }, 		
    { 0x3810, 0x00 }, 
    { 0x3811, 0x10 }, 
    { 0x3812, 0x00 }, 
    { 0x3813, 0x06 }, 
    { 0x3814, 0x31 }, 
    { 0x3815, 0x31 },		
    
    { 0x3034, 0x1a }, 
    { 0x3035, 0x21 }, //15fps
    { 0x3036, 0x46 }, 
    { 0x3037, 0x13 }, 
    { 0x3038, 0x00 }, 
    { 0x3039, 0x00 }, 
    
    { 0x380c, 0x07 }, 
    { 0x380d, 0x68 }, 
    { 0x380e, 0x03 }, //03
    { 0x380f, 0xd8 }, //d8
        
    { 0x3c01, 0xb4 }, 
    { 0x3c00, 0x04 }, 
    { 0x3a08, 0x00 }, 
    { 0x3a09, 0x93 }, 
    { 0x3a0e, 0x06 },
    { 0x3a0a, 0x00 }, 
    { 0x3a0b, 0x7b }, 		 
    { 0x3a0d, 0x08 }, 
    
    { 0x3a00, 0x3c }, //15fps-10fps
    { 0x3a02, 0x05 }, 
    { 0x3a03, 0xc4 }, 
    { 0x3a14, 0x05 }, 
    { 0x3a15, 0xc4 }, 
    
    { 0x3618, 0x00 }, 
    { 0x3612, 0x29 }, 
    { 0x3708, 0x64 }, 
    { 0x3709, 0x52 }, 
    { 0x370c, 0x03 },
    
    { 0x4001, 0x02 }, 
    { 0x4004, 0x02 }, 
    { 0x3000, 0x00 }, 
    { 0x3002, 0x1c }, 
    { 0x3004, 0xff }, 
    { 0x3006, 0xc3 }, 
    { 0x300e, 0x58 }, 
    { 0x302e, 0x00 }, 
    { 0x4300, 0x30 }, 
    { 0x501f, 0x00 }, 
    { 0x4713, 0x03 }, 
    { 0x4407, 0x04 }, 
    { 0x460b, 0x35 }, 
    { 0x460c, 0x22 },//add by bright 
    { 0x3824, 0x01 },//add by bright 
    { 0x5001, 0xa3 }, 		
    
    { 0x3406, 0x01 },//awbinit
    { 0x3400, 0x06 },
    { 0x3401, 0x80 },
    { 0x3402, 0x04 },
    { 0x3403, 0x00 },
    { 0x3404, 0x06 },
    { 0x3405, 0x00 },
    //awb           
    { 0x5180, 0xff }, 
    { 0x5181, 0xf2 },    
    { 0x5182, 0x00 },   
    { 0x5183, 0x14 },    
    { 0x5184, 0x25 },    
    { 0x5185, 0x24 },    
    { 0x5186, 0x16 },    
    { 0x5187, 0x16 },    
    { 0x5188, 0x16 },    
    { 0x5189, 0x62 },    
    { 0x518a, 0x62 },    
    { 0x518b, 0xf0 },    
    { 0x518c, 0xb2 },    
    { 0x518d, 0x50 },    
    { 0x518e, 0x30 },    
    { 0x518f, 0x30 },    
    { 0x5190, 0x50 },    
    { 0x5191, 0xf8 },    
    { 0x5192, 0x04 },   
    { 0x5193, 0x70 },    
    { 0x5194, 0xf0 },    
    { 0x5195, 0xf0 },    
    { 0x5196, 0x03 },   
    { 0x5197, 0x01 },   
    { 0x5198, 0x04 },   
    { 0x5199, 0x12 },    
    { 0x519a, 0x04 },   
    { 0x519b, 0x00 },   
    { 0x519c, 0x06 },   
    { 0x519d, 0x82 },    
    { 0x519e, 0x38 },  
    //color matrix  	                                        	                                  
    { 0x5381, 0x1e },  
    { 0x5382, 0x5b }, 
    { 0x5383, 0x14 }, 
    { 0x5384, 0x06 }, 
    { 0x5385, 0x82 }, 
    { 0x5386, 0x88 }, 
    { 0x5387, 0x7c }, 
    { 0x5388, 0x60 }, 
    { 0x5389, 0x1c }, 
    { 0x538a, 0x01 }, 
    { 0x538b, 0x98 }, 
    //sharp&noise
    { 0x5300, 0x08 }, 
    { 0x5301, 0x30 }, 
    { 0x5302, 0x3f }, 
    { 0x5303, 0x10 },
    { 0x5304, 0x08 }, 
    { 0x5305, 0x30 }, 
    { 0x5306, 0x18 }, 
    { 0x5307, 0x28 },
    { 0x5309, 0x08 }, 
    { 0x530a, 0x30 }, 
    { 0x530b, 0x04 }, 
    { 0x530c, 0x06 }, 	 
    //gamma                         
    { 0x5480, 0x01 },
    { 0x5481, 0x06 }, 
    { 0x5482, 0x12 },  
    { 0x5483, 0x24 },  
    { 0x5484, 0x4a }, 
    { 0x5485, 0x58 },  
    { 0x5486, 0x65 },  
    { 0x5487, 0x72 },  
    { 0x5488, 0x7d },  
    { 0x5489, 0x88 },  
    { 0x548a, 0x92 },  
    { 0x548b, 0xa3 },  
    { 0x548c, 0xb2 },  
    { 0x548d, 0xc8 },  
    { 0x548e, 0xdd },  
    { 0x548f, 0xf0 }, 
    { 0x5490, 0x15 }, 	  
    //UV adjust                              	                    
    { 0x5580, 0x06 }, 		
    { 0x5583, 0x40 }, 
    { 0x5584, 0x20 }, 
    { 0x5589, 0x10 }, 
    { 0x558a, 0x00 }, 
    { 0x558b, 0xf8 },                                 
    //lens shading                                      
    { 0x5000, 0xa7 },                                      	
    { 0x5800, 0x20 }, 
    { 0x5801, 0x19 }, 
    { 0x5802, 0x17 }, 
    { 0x5803, 0x16 }, 
    { 0x5804, 0x18 }, 
    { 0x5805, 0x21 }, 
    { 0x5806, 0x0F }, 
    { 0x5807, 0x0A }, 
    { 0x5808, 0x07 }, 
    { 0x5809, 0x07 }, 
    { 0x580a, 0x0A }, 
    { 0x580b, 0x0C }, 
    { 0x580c, 0x0A }, 
    { 0x580d, 0x03 }, 
    { 0x580e, 0x01 }, 
    { 0x580f, 0x01 }, 
    { 0x5810, 0x03 }, 
    { 0x5811, 0x09 }, 
    { 0x5812, 0x0A }, 
    { 0x5813, 0x03 }, 
    { 0x5814, 0x01 }, 
    { 0x5815, 0x01 }, 
    { 0x5816, 0x03 }, 
    { 0x5817, 0x08 }, 
    { 0x5818, 0x10 }, 
    { 0x5819, 0x0A }, 
    { 0x581a, 0x06 }, 
    { 0x581b, 0x06 }, 
    { 0x581c, 0x08 }, 
    { 0x581d, 0x0E }, 
    { 0x581e, 0x22 }, 
    { 0x581f, 0x18 }, 
    { 0x5820, 0x13 }, 
    { 0x5821, 0x12 }, 
    { 0x5822, 0x16 }, 
    { 0x5823, 0x1E }, 
    { 0x5824, 0x64 }, 
    { 0x5825, 0x2A }, 
    { 0x5826, 0x2C }, 
    { 0x5827, 0x2A }, 
    { 0x5828, 0x46 }, 
    { 0x5829, 0x2A }, 
    { 0x582a, 0x26 }, 
    { 0x582b, 0x24 }, 
    { 0x582c, 0x26 }, 
    { 0x582d, 0x2A }, 
    { 0x582e, 0x28 }, 
    { 0x582f, 0x42 }, 
    { 0x5830, 0x40 }, 
    { 0x5831, 0x42 }, 
    { 0x5832, 0x08 }, 
    { 0x5833, 0x28 }, 
    { 0x5834, 0x26 }, 
    { 0x5835, 0x24 }, 
    { 0x5836, 0x26 }, 
    { 0x5837, 0x2A }, 
    { 0x5838, 0x44 }, 
    { 0x5839, 0x4A }, 
    { 0x583a, 0x2C }, 
    { 0x583b, 0x2a }, 
    { 0x583c, 0x46 }, 
    { 0x583d, 0xCE }, 	
    
    { 0x5688, 0x22 }, 
    { 0x5689, 0x22 }, 
    { 0x568a, 0x42 }, 
    { 0x568b, 0x24 }, 
    { 0x568c, 0x42 }, 
    { 0x568d, 0x24 }, 
    { 0x568e, 0x22 }, 
    { 0x568f, 0x22 }, 
    
    { 0x5025, 0x00 }, 
    
    { 0x3a0f, 0x30 },
    { 0x3a10, 0x28 }, 
    { 0x3a1b, 0x30 }, 
    { 0x3a1e, 0x28 }, 
    { 0x3a11, 0x61 }, 
    { 0x3a1f, 0x10 }, 
    
    { 0x4005, 0x1a },
    { 0x3406, 0x00 },//awbinit
    { 0x3503, 0x00 },//awbinit
    { 0x3008, 0x02 }, 
    { 0xFFFF, 0xFF },	
};

static struct sensor_reg OV5640_JPEG_QSXGA[] =
{	//2592x1944 QSXGA
    {0x3820 ,0x40}, 
    {0x3821 ,0x26}, 
    {0x3814 ,0x11}, 
    {0x3815 ,0x11}, 
    {0x3803 ,0x00}, 
    {0x3807 ,0x9f}, 
    {0x3808 ,0x0a}, 
    {0x3809 ,0x20}, 
    {0x380a ,0x07}, 
    {0x380b ,0x98},
    {0x380c ,0x0b},                                                                    
    {0x380d ,0x1c}, 
    {0x380e ,0x07},                                                         
    {0x380f ,0xb0},                                                          
    {0x3813 ,0x04},                                                     
    {0x3618 ,0x04},                        
    {0x3612 ,0x4b},                                               
    {0x3708 ,0x64},                
    {0x3709 ,0x12},                                    
    {0x370c ,0x00},  
    {0x3a02 ,0x07},                             
    {0x3a03 ,0xb0},                        
    {0x3a0e ,0x06},                    
    {0x3a0d ,0x08}, 
    {0x3a14 ,0x07}, 
    {0x3a15 ,0xb0}, 
    {0x4001 ,0x02}, 
    {0x4004 ,0x06}, 
    {0x3002 ,0x00}, 
    {0x3006 ,0xff}, 
    {0x3824 ,0x04}, 
    {0x5001 ,0x83}, 
    {0x3036 ,0x69}, 
    {0x3035 ,0x31}, 
    {0x4005 ,0x1A},
    {0xFFFF, 0xFF},
};

static struct sensor_reg OV5640_QSXGA2QVGA[] =
{	//320x240 QVGA
    {0x3800 ,0x00},                            
    {0x3801 ,0x00},                                                            
    {0x3802 ,0x00},                            
    {0x3803 ,0x00},   
    {0x3804 ,0xA },           
    {0x3805 ,0x3f},          
    {0x3806 ,0x7 },          
    {0x3807 ,0x9f},          
    {0x3808 ,0x1 },                               
    {0x3809 ,0x40},  
    {0x380a ,0x0 },           
    {0x380b ,0xf0}, 
    {0x380c ,0xc },                        
    {0x380d ,0x80},                      
    {0x380e ,0x7 }, 
    {0x380f ,0xd0}, 
    {0x5001 ,0xa3}, 
    {0x5680 ,0x0 }, 
    {0x5681 ,0x0 }, 
    {0x5682 ,0xA }, 
    {0x5683 ,0x20}, 
    {0x5684 ,0x0 }, 
    {0x5685 ,0x0 }, 
    {0x5686 ,0x7 }, 
    {0x5687 ,0x98}, 	
    {0xFFFF, 0xFF},		
};

static struct sensor_reg OV5640_QSXGA2UXGA[] =	
{	//1600x1200 UXGA
    {0x3800 ,0x00},
    {0x3801 ,0x00},
    {0x3802 ,0x00},
    {0x3803 ,0x00},
    {0x3804 ,0xA },
    {0x3805 ,0x3f},
    {0x3806 ,0x7 },
    {0x3807 ,0x9f},
    {0x3808 ,0x6 },
    {0x3809 ,0x40},
    {0x380a ,0x4 },
    {0x380b ,0xb0},
    {0x380c ,0xc },
    {0x380d ,0x80},
    {0x380e ,0x7 },
    {0x380f ,0xd0},
    {0x5001 ,0xa3},
    {0x5680 ,0x0 },
    {0x5681 ,0x0 },
    {0x5682 ,0xA },
    {0x5683 ,0x20},
    {0x5684 ,0x0 },
    {0x5685 ,0x0 },
    {0x5686 ,0x7 },
    {0x5687 ,0x98},
    {0xFFFF, 0xFF},
};

static struct sensor_reg OV5640_5MP_JPEG[] =
{	//5MP
    {0x3800 ,0x00},                            
    {0x3801 ,0x00},                                                            
    {0x3802 ,0x00},                            
    {0x3803 ,0x00},   
    {0x3804 ,0xA },           
    {0x3805 ,0x3f},          
    {0x3806 ,0x7 },          
    {0x3807 ,0x9f},          
    {0x3808 ,0xA },                               
    {0x3809 ,0x20},  
    {0x380a ,0x7 },           
    {0x380b ,0x98}, 
    {0x380c ,0xc },                        
    {0x380d ,0x80},                      
    {0x380e ,0x7 }, 
    {0x380f ,0xd0}, 
    {0x5001 ,0xa3}, 
    {0x5680 ,0x0 }, 
    {0x5681 ,0x0 }, 
    {0x5682 ,0xA }, 
    {0x5683 ,0x20}, 
    {0x5684 ,0x0 }, 
    {0x5685 ,0x0 }, 
    {0x5686 ,0x7 }, 
    {0x5687 ,0x98}, 	
    {0xFFFF, 0xFF},	
};

#endif

#ifdef OV5642
static struct sensor_reg ov5642_dvp_fmt_jpeg_qvga[] =
{
    {0x3819, 0x81},
    {0x3503, 0x00},	//AWE Manual Mode Control //0x07
    {0x3002, 0x00},
    {0x3003, 0x00},
    {0x3005, 0xff},
    {0x3006, 0xff},
    {0x3007 ,0x3f},
    {0x3602 ,0xe4},
    {0x3603 ,0x27},
    {0x3604 ,0x60},
    {0x3612 ,0xac},
    {0x3613 ,0x44},
    {0x3622 ,0x08},
    {0x3623 ,0x22},
    {0x3621 ,0x27},
    {0x3705 ,0xda},
    {0x370a ,0x80},
    {0x3800 ,0x01},
    {0x3801 ,0x8a},
    {0x3802 ,0x00},
    {0x3803 ,0x0a},
    {0x3804 ,0x0a},
    {0x3805 ,0x20},
    {0x3806 ,0x07},
    {0x3807 ,0x98},

    {0x3808 ,0x01},
    {0x3809 ,0x40},
    {0x380a ,0x00},
    {0x380b ,0xf0},

    {0x380c ,0x0c},
    {0x380d ,0x80},
    {0x380e ,0x07},
    {0x380f ,0xd0},
    {0x3810 ,0xc2},
    {0x3815 ,0x44},
    {0x3818 ,0xa8},
    {0x3824 ,0x01},
    {0x3827 ,0x0a},
    {0x3a00 ,0x78},
    {0x3a0d ,0x10},
    {0x3a0e ,0x0d},
    {0x3a00 ,0x78},
    {0x460b ,0x35},
    {0x471d ,0x00},
    {0x471c ,0x50},
    {0x5682 ,0x0a},
    {0x5683 ,0x20},
    {0x5686 ,0x07},
    {0x5687 ,0x98},
    {0x589b ,0x00},
    {0x589a ,0xc0},
    {0x4407 ,0x04},
    {0x589b ,0x00},
    {0x589a ,0xc0},
    {0x3002 ,0x0c},
    {0x3002 ,0x00},
    {0x4300 ,0x32},
    {0x460b ,0x35},
    {0x3002 ,0x0c},
    {0x3002 ,0x00},
    {0x4713 ,0x02},
    {0x4600 ,0x80},
    {0x4721 ,0x02},
    {0x471c ,0x40},
    {0x4408 ,0x00},
    {0x460c ,0x22},
    {0x3815 ,0x04},
    {0x3818 ,0xe8},//c8
    {0x501f ,0x00},
    {0x5002 ,0xe0},
    {0x440a ,0x01},
    {0x4402 ,0x90},
    {0x3811 ,0xf0},		//4:3 thumbnail 				// 0x size sensor.....

    {0x471c ,0x50},
    {0x3815 ,0x44},
    {0x3818 ,0xe8},//c8
    {0x4740 ,0x20},
    {0x3030 ,0x0b},//2b
    {0x350c ,0x07},
    {0x350d ,0xd0},
    {0x5001 ,0xFF},
    {0x3010 ,0x30},

    {0x460d,0xdd},//  dummy data

    /* test color bar */
    //{0x503d , 0x80},
    //{0x503e, 0x00},

    //11 fps
    {0x300F, 0x0a},
    {0x3010 ,0x00},
    {0x3011, 0x06},
    {0x3012 ,0x00},

    //{0x4407 ,0x00},

    {0xffff, 0xff},
};

static struct sensor_reg ov5642_dvp_fmt_jpeg_qxga[] =
{
    {0x3819, 0x81},
    {0x3503, 0x00},	//AWE Manual Mode Control //0x07
    {0x3002, 0x00},
    {0x3003, 0x00},
    {0x3005, 0xff},
    {0x3006, 0xff},
    {0x3007 ,0x3f},
    {0x3602 ,0xe4},
    {0x3603 ,0x27},
    {0x3604 ,0x60},
    {0x3612 ,0xac},
    {0x3613 ,0x44},
    {0x3622 ,0x08},
    {0x3623 ,0x22},
    {0x3621 ,0x27},
    {0x3705 ,0xda},
    {0x370a ,0x80},
    {0x3800 ,0x01},
    {0x3801 ,0x8a},
    {0x3802 ,0x00},
    {0x3803 ,0x0a},
    {0x3804 ,0x0a},
    {0x3805 ,0x20},
    {0x3806 ,0x07},
    {0x3807 ,0x98},

    {0x3808 ,0x08},
    {0x3809 ,0x00},
    {0x380a ,0x06},
    {0x380b ,0x00},

    {0x380c ,0x0c},
    {0x380d ,0x80},
    {0x380e ,0x07},
    {0x380f ,0xd0},
    {0x3810 ,0xc2},
    {0x3815 ,0x44},
    {0x3818 ,0xa8},
    {0x3824 ,0x01},
    {0x3827 ,0x0a},
    {0x3a00 ,0x78},
    {0x3a0d ,0x10},
    {0x3a0e ,0x0d},
    {0x3a00 ,0x78},
    {0x460b ,0x35},
    {0x471d ,0x00},
    {0x471c ,0x50},
    {0x5682 ,0x0a},
    {0x5683 ,0x20},
    {0x5686 ,0x07},
    {0x5687 ,0x98},
    {0x589b ,0x00},
    {0x589a ,0xc0},
    {0x4407 ,0x04},
    {0x589b ,0x00},
    {0x589a ,0xc0},
    {0x3002 ,0x0c},
    {0x3002 ,0x00},
    {0x4300 ,0x32},
    {0x460b ,0x35},
    {0x3002 ,0x0c},
    {0x3002 ,0x00},
    {0x4713 ,0x02},
    {0x4600 ,0x80},
    {0x4721 ,0x02},
    {0x471c ,0x40},
    {0x4408 ,0x00},
    {0x460c ,0x22},
    {0x3815 ,0x04},
    {0x3818 ,0xc8},
    {0x501f ,0x00},
    {0x5002 ,0xe0},
    {0x440a ,0x01},
    {0x4402 ,0x90},
    {0x3811 ,0xf0},		//4:3 thumbnail 				// 0x size sensor.....

    {0x471c ,0x50},
    {0x3815 ,0x44},
    {0x3818 ,0xc8},
    {0x4740 ,0x20},
    {0x3030 ,0x0b},//2b
    {0x350c ,0x07},
    {0x350d ,0xd0},
    {0x5001 ,0xFF},
    {0x3010 ,0x30},

    {0x460d,0xdd},//  dummy data

    /* test color bar */
    //{0x503d , 0x80},
    // {0x503e, 0x00},

    //11 fps
    {0x300F, 0x0a},
    {0x3010 ,0x00},
    {0x3011, 0x06},
    {0x3012 ,0x00},



    {0xffff, 0xff},
};

static struct sensor_reg ov5642_dvp_fmt_jpeg_5M[] =
{
    {0x3819, 0x81},
    {0x3503, 0x00},	//AWE Manual Mode Control //0x07
    {0x3002, 0x00},
    {0x3003, 0x00},
    {0x3005, 0xff},
    {0x3006, 0xff},
    {0x3007 ,0x3f},
    {0x3602 ,0xe4},
    {0x3603 ,0x27},
    {0x3604 ,0x60},
    {0x3612 ,0xac},
    {0x3613 ,0x44},
    {0x3622 ,0x08},
    {0x3623 ,0x22},
    {0x3621 ,0x27},
    {0x3705 ,0xda},
    {0x370a ,0x80},
    {0x3800 ,0x01},
    {0x3801 ,0x8a},
    {0x3802 ,0x00},
    {0x3803 ,0x0a},
    {0x3804 ,0x0a},
    {0x3805 ,0x20},
    {0x3806 ,0x07},
    {0x3807 ,0x98},
    {0x3808 ,0x0a},
    {0x3809 ,0x20},
    {0x380a ,0x07},
    {0x380b ,0x98},
    {0x380c ,0x0c},
    {0x380d ,0x80},
    {0x380e ,0x07},
    {0x380f ,0xd0},
    {0x3810 ,0xc2},
    {0x3815 ,0x44},
    {0x3818 ,0xa8},
    {0x3824 ,0x01},
    {0x3827 ,0x0a},
    {0x3a00 ,0x78},
    {0x3a0d ,0x10},
    {0x3a0e ,0x0d},
    {0x3a00 ,0x78},
    {0x460b ,0x35},
    {0x471d ,0x00},
    {0x471c ,0x50},
    {0x5682 ,0x0a},
    {0x5683 ,0x20},
    {0x5686 ,0x07},
    {0x5687 ,0x98},
    {0x589b ,0x00},
    {0x589a ,0xc0},
    {0x4407 ,0x04},//0x04
    {0x589b ,0x00},
    {0x589a ,0xc0},
    {0x3002 ,0x0c},
    {0x3002 ,0x00},
    {0x4300 ,0x32},
    {0x460b ,0x35},
    {0x3002 ,0x0c},
    {0x3002 ,0x00},
    {0x4713 ,0x02},
    {0x4600 ,0x80},
    {0x4721 ,0x02},
    {0x471c ,0x40},
    {0x4408 ,0x00},
    {0x460c ,0x22},
    {0x3815 ,0x04},
    {0x3818 ,0xc8},
    {0x501f ,0x00},
    {0x5002 ,0xe0},
    {0x440a ,0x01},
    {0x4402 ,0x90},
    {0x3811 ,0xf0},		//4:3 thumbnail 				// 0x size sensor.....

    {0x471c ,0x50},
    {0x3815 ,0x44},
    {0x3818 ,0xe8},//c8
    {0x4740 ,0x20},
    {0x3030 ,0x0b},//2b
    {0x350c ,0x07},
    {0x350d ,0xd0},
    {0x5001 ,0xFF},
    {0x3010 ,0x30},

    {0x460d,0xdd},//  dummy data
    /*
    {0x4300, 0x30},
    {0x460b, 0x37},
    {0x3002, 0x0c},
    {0x3002, 0x00},
    {0x4713, 0x02},
    {0x4600, 0xa0},
    {0x4721, 0x02},
    {0x471c, 0x40},
    {0x4408, 0x00},
    {0x460c, 0x22},
    {0x3815, 0x04},
    {0x3818, 0xc8},// ;TN_dis
    {0x501f, 0x00},
    {0x5002, 0xe0},
    {0x440a, 0x01},
    {0x4402, 0x90},
    {0x4602, 0x04},
    {0x4603, 0x00},
    {0x4604, 0x06},
    {0x4605, 0x00},
    */
    /* test color bar */
    //{0x503d , 0x80},
    //{0x503e, 0x00},

    //11 fps
    {0x300F, 0x0a},
    {0x3010 ,0x00},
    {0x3011, 0x08},//06
    {0x3012 ,0x00},

    {0xffff, 0xff},
};  

static struct sensor_reg ov5642_dvp_fmt_global_init[] =
{
    {0x3103, 0x93},
    {0x3008, 0x82},
    {0x3017, 0x7f},
    {0x3018, 0xfc},
    {0x3810, 0xc2},
    {0x3615, 0xf0},
    {0x3000, 0x00},
    {0x3001, 0x00},
    {0x3002, 0x00},
    {0x3003, 0x00},
    {0x3000, 0xf8},
    {0x3001, 0x48},
    {0x3002, 0x5c},
    {0x3003, 0x02},
    {0x3004, 0x07},
    {0x3005, 0xb7},
    {0x3006, 0x43},
    {0x3007, 0x37},
    {0x3011, 0x07},

    // fps	25fps
    //{0x300F, 0x0a},
    //{0x3010 ,0x00},
    //{0x3011, 0x07},
    //{0x3012 ,0x00},

    {0x370c, 0xa0},
    {0x3602, 0xfc},
    {0x3612, 0xff},
    {0x3634, 0xc0},
    {0x3613, 0x00},
    {0x3605, 0x7c},
    {0x3622, 0x60},
    {0x3604, 0x40},
    {0x3603, 0xa7},
    {0x3603, 0x27},
    {0x4000, 0x21},
    {0x401d, 0x22},
    {0x3600, 0x54},
    {0x3605, 0x04},
    {0x3606, 0x3f},
    {0x3c01, 0x80},
    {0x5000, 0x4f},
    {0x5020, 0x04},
    {0x5500, 0x0a},
    {0x5504, 0x00},
    {0x5505, 0x7f},
    {0x5080, 0x08},
    {0x300e, 0x18},
    {0x4610, 0x00},
    {0x471d, 0x05},
    {0x4708, 0x06},
    {0x4300, 0x32},
    {0x3503, 0x07},
    {0x3501, 0x73},
    {0x3502, 0x80},
    {0x350b, 0x00},
    {0x3503, 0x07},
    //{0x3824, 0x11},
    {0x3501, 0x1e},
    {0x3502, 0x80},
    {0x350b, 0x7f},
    {0x3a0d, 0x04},
    {0x3a0e, 0x03},
    {0x3705, 0xdb},
    {0x370a, 0x81},
    {0x3801, 0x80},
    {0x3801, 0x50},
    {0x3803, 0x08},
    //{0x3827, 0x08},
    {0x3810, 0x40},
    {0x3a00, 0x78},
    {0x3a1a, 0x05},
    {0x3a13, 0x30},
    {0x3a18, 0x00},
    {0x3a19, 0x7c},
    {0x3a08, 0x12},
    {0x3a09, 0xc0},
    {0x3a0a, 0x0f},
    {0x3a0b, 0xa0},
    {0x3004, 0xff},
    {0x350c, 0x07},
    {0x350d, 0xd0},
    {0x3500, 0x00},
    {0x3501, 0x00},
    {0x3502, 0x00},
    {0x350a, 0x00},
    {0x350b, 0x00},
    {0x3503, 0x00},
    {0x3a0f, 0x3c},
    {0x3a10, 0x30},
    {0x3a1b, 0x3c},
    {0x3a1e, 0x30},
    {0x3a11, 0x70},
    {0x3a1f, 0x10},
    {0x3030, 0x0b},//2b
    {0x3a02, 0x00},
    {0x3a03, 0x7d},
    {0x3a04, 0x00},
    {0x3a14, 0x00},
    {0x3a15, 0x7d},
    {0x3a16, 0x00},
    {0x3a00, 0x78},
    {0x3a08, 0x09},
    {0x3a09, 0x60},
    {0x3a0a, 0x07},
    {0x3a0b, 0xd0},
    {0x3a0d, 0x08},
    {0x3a0e, 0x06},
    {0x5193, 0x70},
    {0x589b, 0x04},
    {0x589a, 0xc5},
    {0x401e, 0x20},
    {0x4001, 0x42},
    {0x401c, 0x04},
    {0x5300, 0x00},
    {0x5301, 0x20},
    {0x5302, 0x00},
    {0x5303, 0x7c},
    {0x530c, 0x00},
    {0x530d, 0x0c},
    {0x530e, 0x20},
    {0x530f, 0x80},
    {0x5310, 0x20},
    {0x5311, 0x80},
    {0x5308, 0x20},
    {0x5309, 0x40},
    {0x5304, 0x00},
    {0x5305, 0x30},
    {0x5306, 0x00},
    {0x5307, 0x80},
    {0x5314, 0x08},
    {0x5315, 0x20},
    {0x5319, 0x30},
    {0x5316, 0x10},
    {0x5317, 0x08},
    {0x5318, 0x02},

    //color matrix
    {0x5380, 0x1 },
    {0x5381, 0x0 },
    {0x5382, 0x0 },
    {0x5383, 0x1a},
    {0x5384, 0x0 },
    {0x5385, 0x1a},
    {0x5386, 0x0 },
    {0x5387, 0x0 },
    {0x5388, 0x1 },
    {0x5389, 0x3c},
    {0x538a, 0x0 },
    {0x538b, 0x35},
    {0x538c, 0x0 },
    {0x538d, 0x0 },
    {0x538e, 0x0 },
    {0x538f, 0x05},
    {0x5390, 0x0 },
    {0x5391, 0xe8},
    {0x5392, 0x0 },
    {0x5393, 0xa2},
    {0x5394, 0x8 },

    //gamma
    {0x5480, 0xd },
    {0x5481, 0x18},
    {0x5482, 0x2a},
    {0x5483, 0x49},
    {0x5484, 0x56},
    {0x5485, 0x62},
    {0x5486, 0x6c},
    {0x5487, 0x76},
    {0x5488, 0x80},
    {0x5489, 0x88},
    {0x548a, 0x96},
    {0x548b, 0xa2},
    {0x548c, 0xb8},
    {0x548d, 0xcc},
    {0x548e, 0xe0},
    {0x548f, 0x10},
    {0x5490, 0x3 },
    {0x5491, 0x40},
    {0x5492, 0x3 },
    {0x5493, 0x0 },
    {0x5494, 0x2 },
    {0x5495, 0xa0},
    {0x5496, 0x2 },
    {0x5497, 0x48},
    {0x5498, 0x2 },
    {0x5499, 0x26},
    {0x549a, 0x2 },
    {0x549b, 0xb },
    {0x549c, 0x1 },
    {0x549d, 0xee},
    {0x549e, 0x1 },
    {0x549f, 0xd8},
    {0x54a0, 0x1 },
    {0x54a1, 0xc7},
    {0x54a2, 0x1 },
    {0x54a3, 0xb3},
    {0x54a4, 0x1 },
    {0x54a5, 0x90},
    {0x54a6, 0x1 },
    {0x54a7, 0x62},
    {0x54a8, 0x1 },
    {0x54a9, 0x27},
    {0x54aa, 0x01},
    {0x54ab, 0x09},
    {0x54ac, 0x01},
    {0x54ad, 0x00},
    {0x54ae, 0x0 },
    {0x54af, 0x40},
    {0x54b0, 0x1 },
    {0x54b1, 0x20},
    {0x54b2, 0x1 },
    {0x54b3, 0x40},
    {0x54b4, 0x0 },
    {0x54b5, 0xf0},
    {0x54b6, 0x1 },
    {0x54b7, 0xdf},

    //saturation
    {0x5583, 0x3a}, //ken 20100106
    {0x5584, 0x3a}, //ken 20100106

    {0x5580, 0x02},
    {0x5000, 0xcf},

    //for sunny
    //lens shading
    {0x5800, 0x35},
    {0x5801, 0x20},
    {0x5802, 0x17},
    {0x5803, 0x17},
    {0x5804, 0x18},
    {0x5805, 0x1E},
    {0x5806, 0x2D},
    {0x5807, 0x47},
    {0x5808, 0x17},
    {0x5809, 0x11},
    {0x580a, 0xC },
    {0x580b, 0xB },
    {0x580c, 0xC },
    {0x580d, 0x10},
    {0x580e, 0x17},
    {0x580f, 0x23},
    {0x5810, 0x10},
    {0x5811, 0xA },
    {0x5812, 0x5 },
    {0x5813, 0x3 },
    {0x5814, 0x4 },
    {0x5815, 0x8 },
    {0x5816, 0xF },
    {0x5817, 0x19},
    {0x5818, 0xE },
    {0x5819, 0x7 },
    {0x581a, 0x2 },
    {0x581b, 0x3 },
    {0x581c, 0x3 },
    {0x581d, 0x4 },
    {0x581e, 0xD },
    {0x581f, 0x16},
    {0x5820, 0xF },
    {0x5821, 0x8 },
    {0x5822, 0x2 },
    {0x5823, 0x3 },
    {0x5824, 0x3 },
    {0x5825, 0x5 },
    {0x5826, 0xE },
    {0x5827, 0x19},
    {0x5828, 0x11},
    {0x5829, 0xB },
    {0x582a, 0x6 },
    {0x582b, 0x3 },
    {0x582c, 0x4 },
    {0x582d, 0x8 },
    {0x582e, 0x10},
    {0x582f, 0x19},
    {0x5830, 0x19},
    {0x5831, 0x11},
    {0x5832, 0xC },
    {0x5833, 0xB },
    {0x5834, 0xB },
    {0x5835, 0x10},
    {0x5836, 0x17},
    {0x5837, 0x23},
    {0x5838, 0x35},
    {0x5839, 0x1F},
    {0x583a, 0x16},
    {0x583b, 0x12},
    {0x583c, 0x14},
    {0x583d, 0x19},
    {0x583e, 0x26},
    {0x583f, 0x3D},
    {0x5840, 0xF },
    {0x5841, 0xE },
    {0x5842, 0xD },
    {0x5843, 0xD },
    {0x5844, 0xE },
    {0x5845, 0x10},
    {0x5846, 0xF },
    {0x5847, 0xE },
    {0x5848, 0xE },
    {0x5849, 0xE },
    {0x584a, 0xE },
    {0x584b, 0xD },
    {0x584c, 0xE },
    {0x584d, 0xF },
    {0x584e, 0x10},
    {0x584f, 0xF },
    {0x5850, 0xF },
    {0x5851, 0xD },
    {0x5852, 0xE },
    {0x5853, 0xF },
    {0x5854, 0xF },
    {0x5855, 0xF },
    {0x5856, 0xF },
    {0x5857, 0xD },
    {0x5858, 0x10},
    {0x5859, 0xE },
    {0x585a, 0xF },
    {0x585b, 0xF },
    {0x585c, 0xE },
    {0x585d, 0xD },
    {0x585e, 0xD },
    {0x585f, 0xC },
    {0x5860, 0xB },
    {0x5861, 0xC },
    {0x5862, 0xC },
    {0x5863, 0xD },
    {0x5864, 0x12},
    {0x5865, 0x13},
    {0x5866, 0x14},
    {0x5867, 0x14},
    {0x5868, 0x12},
    {0x5869, 0x11},
    {0x586a, 0x14},
    {0x586b, 0x11},
    {0x586c, 0x10},
    {0x586d, 0x10},
    {0x586e, 0x11},
    {0x586f, 0x14},
    {0x5870, 0x14},
    {0x5871, 0xF },
    {0x5872, 0xF },
    {0x5873, 0xF },
    {0x5874, 0xF },
    {0x5875, 0x12},
    {0x5876, 0x14},
    {0x5877, 0xF },
    {0x5878, 0xF },
    {0x5879, 0xF },
    {0x587a, 0xF },
    {0x587b, 0x13},
    {0x587c, 0x14},
    {0x587d, 0x12},
    {0x587e, 0x10},
    {0x587f, 0x10},
    {0x5880, 0x11},
    {0x5881, 0x13},
    {0x5882, 0x13},
    {0x5883, 0x13},
    {0x5884, 0x16},
    {0x5885, 0x16},
    {0x5886, 0x13},
    {0x5887, 0x13},

    {0x3710, 0x10},
    {0x3632, 0x51},
    {0x3702, 0x10},
    {0x3703, 0xb2},
    {0x3704, 0x18},
    {0x370b, 0x40},
    {0x370d, 0x03},
    {0x3631, 0x01},
    {0x3632, 0x52},
    {0x3606, 0x24},
    {0x3620, 0x96},
    {0x5785, 0x07},
    {0x3a13, 0x30},
    {0x3600, 0x52},
    {0x3604, 0x48},
    {0x3606, 0x1b},
    {0x370d, 0x0b},
    {0x370f, 0xc0},
    {0x3709, 0x01},
    {0x3823, 0x00},
    {0x5007, 0x00},
    {0x5009, 0x00},
    {0x5011, 0x00},
    {0x5013, 0x00},
    {0x519e, 0x00},
    {0x5086, 0x00},
    {0x5087, 0x00},
    {0x5088, 0x00},
    {0x5089, 0x00},
    {0x302b, 0x00},

    {0x4740, 0x20},
    {0x3c00, 0x04},
    {0x3012, 0x00},

    //denoise YUV
    {0x528a, 0x02},
    {0x528b, 0x06},
    {0x528c, 0x20},
    {0x528d, 0x30},
    {0x528e, 0x40},
    {0x528f, 0x50},
    {0x5290, 0x60},
    {0x5292, 0x00},
    {0x5293, 0x02},
    {0x5294, 0x00},
    {0x5295, 0x04},
    {0x5296, 0x00},
    {0x5297, 0x08},
    {0x5298, 0x00},
    {0x5299, 0x10},
    {0x529a, 0x00},
    {0x529b, 0x20},
    {0x529c, 0x00},
    {0x529d, 0x28},
    {0x529e, 0x00},
    {0x529f, 0x30},
    {0x5282, 0x00},

    {0x350b, 0x0f},
    {0x3a19, 0x00},
    {0x3001, 0x48},
    {0x3002, 0x5c},
    {0x3003, 0x02},
    {0x3004, 0xFF},
    {0x3005, 0xb7},
    {0x3006, 0x43},
    {0x3007, 0x37},
    {0x3a19, 0xff},
    {0x350c, 0x07},
    {0x350d, 0xd0},
    {0x3602, 0xfc},
    {0x3612, 0xff},
    {0x3613, 0x00},
    {0x3621, 0x87},
    {0x3622, 0x60},
    {0x3623, 0x01},
    {0x3604, 0x48},
    {0x3705, 0xdb},
    {0x370a, 0x81},
    {0x3801, 0x50},
    {0x3803, 0x08},
    {0x3804, 0x05},
    {0x3805, 0x00},
    {0x3806, 0x03},
    {0x3807, 0xc0},
    {0x3808, 0x01},
    {0x3809, 0x40},
    {0x380a, 0x00},
    {0x380b, 0xf0},
    {0x380c, 0x0c},
    {0x380d, 0x80},

    {0x380E, 0x03},
    {0x380F, 0xe8},

    {0x3810, 0x40},
    {0x3824, 0x11},
    {0x3827, 0x08},
    {0x3a00, 0x78},
    {0x3a0d, 0x08},
    {0x3a0e, 0x06},
    {0x3a11, 0xd0},
    {0x3a1f, 0x40},
    {0x460b, 0x37},
    {0x471d, 0x05},
    {0x4713, 0x02},
    {0x471c, 0xd0},
    {0x5001, 0xff},
    {0x589b, 0x04},
    {0x589a, 0xc5},
    {0x4407, 0x0c},
    {0x3002, 0x5c},
    {0x3002, 0x5c},
    {0x3503, 0x00},
    {0x460c, 0x22},
    {0x460b, 0x37},
    {0x471c, 0xd0},
    {0x471d, 0x05},
    {0x3818, 0xc1},
    {0x501f, 0x00},
    {0x3002, 0x5c},
    {0x3819, 0x80},
    {0x5002, 0xe0},
    {0x3503, 0x00},
    //ex weight
    {0x5688, 0x11},
    {0x5689, 0x11},
    {0x568a, 0x11},
    {0x568b, 0x11},
    {0x568c, 0x11},
    {0x568d, 0x11},
    {0x568e, 0x11},
    {0x568f, 0x11},

    {0x350b, 0x3f},
    {0x3503, 0x00},
    {0x3a19, 0x7c},
    //ex window
    {0x5680, 0x00},
    {0x5681, 0x00},
    {0x5682, 0x05},
    {0x5683, 0x00},
    {0x5684, 0x00},
    {0x5685, 0x00},
    {0x5686, 0x03},
    {0x5687, 0xc0},

    //awb 20100205 kenxu
    {0x5180, 0xff},
    {0x5181, 0x52},
    {0x5182, 0x11},
    {0x5183, 0x14},
    {0x5184, 0x25},
    {0x5185, 0x24},
    {0x5186, 0x0c},
    {0x5187, 0x16},
    {0x5188, 0x10},
    {0x5189, 0x64},
    {0x518a, 0x69},
    {0x518b, 0xff},
    {0x518c, 0x84},
    {0x518d, 0x3b},
    {0x518e, 0x41},
    {0x518f, 0x4f},
    {0x5190, 0x50},
    {0x5191, 0xf8},
    {0x5192, 0x04},
    {0x5193, 0x70},
    {0x5194, 0xf0},
    {0x5195, 0xf0},
    {0x5196, 0x03},
    {0x5197, 0x01},
    {0x5198, 0x06},
    {0x5199, 0x12},
    {0x519a, 0x04},
    {0x519b, 0x00},
    {0x519c, 0x05},
    {0x519d, 0x9b},
    {0x519e, 0x00},

    //ken modify 20091208

    {0x3010, 0x10},
    {0x3815, 0x07}, //24M DVP CLOCK

    //AEC/AGC setting
    //Make sure use AEC/AGC source before gamma (0x5025 = 0x80)
    {0x5025, 0x80},
    {0x3a0f, 0x48},
    {0x3a10, 0x40},
    {0x3a1b, 0x4a},
    {0x3a1e, 0x3e},
    {0x3a11, 0x70},
    {0x3a1f, 0x20},

    //Gamma related setting
    {0x54B0, 0x1 }, //ADD
    {0x54B1, 0x20},
    {0x54B2, 0x0},
    {0x54B3, 0x10},
    {0x54B4, 0x0},
    {0x54B5, 0xf0},
    {0x54B6, 0x0},
    {0x54B7, 0xDF},

    //De-noise setting
    {0x5317, 0x00}, //08

    //Auto Sharpness    +1
    {0x530c, 0x04},
    {0x530d, 0x18},
    {0x5312, 0x20},

    {0xFFFF, 0xFF}
};
#endif

/*******************************************************************************
** Private Function Prototypes
*******************************************************************************/
#ifdef OV5642
static int32 CAM_setSize_OV5642(void);
#endif
static int32 arducam_i2c_write_regs(struct sensor_reg*);

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/*                                                                 */
/* CAM Library Initialization Routine                              */
/* cFE requires that a library have an initialization routine      */ 
/*                                                                 */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
int32 CAM_LibInit(void)
{
    #ifdef STF1_DEBUG
        CFE_EVS_SendEvent(HWLIB_INIT_EID, CFE_EVS_DEBUG, "CAM_LibInit(): Initializing the CAM HW");
    #endif

    return OS_SUCCESS;
}

int32 CAM_init_i2c(void)
{
    uint8_t  data[3];
    int32 result = OS_ERROR;
    uint8_t  temp = 0;
    uint8_t  vid, pid;

    while ( (temp < 10) && (result != OS_SUCCESS) )
    {   
        // Change register set to camera
        #ifdef OV2640
        data[0] = 0xFF; 
        data[1] = 0x01;
        i2c_master_transaction(CAM_I2C, CAM_ADDR, &data, 2, NULL, 0, CAM_TIMEOUT);
        #endif
        #if (defined(OV5640) || defined(OV5642))
        data[0] = 0x00; 
        data[1] = 0xFF;
        data[2] = 0x01;
        i2c_master_transaction(CAM_I2C, CAM_ADDR, &data, 3, NULL, 0, CAM_TIMEOUT);
        #endif

        // Test register 1
        #ifdef OV2640
        data[0] = CHIPID_HIGH; // 0x0A
        data[1] = 0x00;
        i2c_master_transaction(CAM_I2C, CAM_ADDR, &data, 2, &vid, 1, CAM_TIMEOUT);
        #endif
        #if (defined(OV5640) || defined(OV5642))
        data[0] = (CHIPID_HIGH & 0xFF00) >> 8;
        data[1] = (CHIPID_HIGH & 0x00FF);
        i2c_master_transaction(CAM_I2C, CAM_ADDR, &data, 2, &vid, 1, CAM_TIMEOUT);
        #endif

        // Test register 2
        #ifdef OV2640
        data[0] = CHIPID_LOW; // 0x0B
        data[1] = 0x00;
        i2c_master_transaction(CAM_I2C, CAM_ADDR, &data, 2, &pid, 1, CAM_TIMEOUT);
        #endif
        #if (defined(OV5640) || defined(OV5642))
        data[0] = (CHIPID_LOW & 0xFF00) >> 8;
        data[1] = (CHIPID_LOW & 0x00FF);
        i2c_master_transaction(CAM_I2C, CAM_ADDR, &data, 2, &pid, 1, CAM_TIMEOUT);
        #endif
        
        #ifdef STF1_DEBUG
            OS_printf("\n vid = 0x%02x; pid = 0x%02x \n", vid, pid);
        #endif
        if((vid == CAM_VID) && (pid == CAM_PID)) 
        {
            result = OS_SUCCESS;
        }
        temp++;
    }

    return result;
}

int32 CAM_init_spi(void)
{
    int32 result = OS_SUCCESS;
    int32 state = OS_SUCCESS;
    uint8_t spir[2]   = {0x00, 0x00};
    uint8_t temp[2]   = {0x00, 0x00};
    uint8_t writereg[2]   = {0x80, 0x55};
    uint8_t readreg[2]   = {0x00, 0x00};
    uint8_t arduchipmode[2] = {0x82, 0x00};

    // Configure SPI
    CAM_SPI.handle      = 0;        
    CAM_SPI.baudrate    = CAM_SPEED;
    CAM_SPI.cs          = 0;
    CAM_SPI.spi_mode    = 0;
    // Setup spi
    result = spi_init_dev(&CAM_SPI);

    // Select chip
    result = spi_select_chip(&CAM_SPI);
    
    if (result == OS_SUCCESS)
    {
        result = OS_ERROR;
        while ( (temp[1] < 5) && (result != OS_SUCCESS) )
        {   
            // Write value 0x55 into register 0x00
            spi_write(&CAM_SPI, writereg, 2);
            spi_read(&CAM_SPI, spir, 2);
            // Read value at register 0x00            
            spi_write(&CAM_SPI, readreg, 2);
            spi_read(&CAM_SPI, spir, 2); 
            #ifdef STF1_DEBUG
                OS_printf("spir 0x%02x%02x \n", spir[0], spir[1]);
            #endif 
            // Check if value was successfully written and returned
            if( (spir[1] & 0xFF) != 0x55 )
            {
                temp[1]++;  
                if (temp[1] == 5)
                {   
                    state = OS_ERROR;
                }  
            }
            else
            {
                result = OS_SUCCESS;

                // Write and verify lots of values over SPI
                /*
                temp = 0;
                while (temp < 255)
                {
                    // Write data
                    gs_spi_write(&chip, temp | 0x8000);
                    gs_spi_read(&chip, &spir);
                    // Read data
                    gs_spi_write(&chip, temp);
                    gs_spi_read(&chip, &spir);
                    // Verify data
                    if ( (spir & 0x00FF) != temp)
                    {
                        OS_printf("SPI Error - failed on verification of 0x%04x \n", temp);
                    }
                    temp++;
                    OS_TaskDelay(1);
                }
                */
                OS_TaskDelay(100);
                // Change mode - MCU
                spi_write(&CAM_SPI, arduchipmode, 2);  //ARDUCHIP_MODE
                OS_TaskDelay(100);
            }
        }

        // Unselect chip
        result = spi_unselect_chip(&CAM_SPI); 
        if (result != OS_SUCCESS)
        {
            state = OS_ERROR;
        }
    }

    return state;
}

int32 CAM_config(void)
{
    uint8_t  data[3];
    int32 result = OS_ERROR;
    uint16_t spir = 0x0000;

    // Select chip
    result = spi_select_chip(&CAM_SPI);

    if (result == OS_SUCCESS)
    {   // arducam_init()
            #ifdef OV2640
            // Change register set to camera
            data[0] = 0xFF; 
            data[1] = 0x01;
            i2c_master_transaction(CAM_I2C, CAM_ADDR, &data, 2, NULL, 0, CAM_TIMEOUT);
            // Common control 7
            data[0] = 0x12; 
            data[1] = 0x80;
            i2c_master_transaction(CAM_I2C, CAM_ADDR, &data, 2, NULL, 0, CAM_TIMEOUT);
            #endif
            #ifdef OV5640
            OS_TaskDelay(100);
            data[0] = 0x31;
            data[1] = 0x03;
            data[2] = 0x11;
            i2c_master_transaction(CAM_I2C, CAM_ADDR, &data, 3, NULL, 0, CAM_TIMEOUT);
            data[0] = 0x30;
            data[1] = 0x08;
            data[2] = 0x82;
            i2c_master_transaction(CAM_I2C, CAM_ADDR, &data, 3, NULL, 0, CAM_TIMEOUT);
            #endif
            #ifdef OV5642
            data[0] = 0x30;
            data[1] = 0x08;
            data[2] = 0x80;
            i2c_master_transaction(CAM_I2C, CAM_ADDR, &data, 3, NULL, 0, CAM_TIMEOUT);
            #endif
            
            OS_TaskDelay(100);

        // Unselect chip
        result = spi_unselect_chip(&CAM_SPI);
        if (result != OS_SUCCESS)
        {
            result = OS_ERROR;
        }
        else
        {
            result = OS_SUCCESS;
        }  
    }

    return result;
}

int32 CAM_jpeg_init(void)
{
    int32 result = OS_SUCCESS;
    #ifdef OV2640
    result = arducam_i2c_write_regs(OV2640_JPEG_INIT);
    #endif
    #ifdef OV5640
    result = arducam_i2c_write_regs(OV5640YUV_Sensor_Dvp_Init);
    #endif
    #ifdef OV5642
    result = arducam_i2c_write_regs(ov5642_dvp_fmt_global_init);
    OS_TaskDelay(100);
    #endif
    return result;
}

int32 CAM_yuv422(void)
{
    int32 result = OS_SUCCESS;
    #ifdef OV2640
    result = arducam_i2c_write_regs(OV2640_YUV422);
    #endif
    #ifdef OV5640
    OS_TaskDelay(500);
    #endif
    #ifdef OV5642
    OS_TaskDelay(100);
    #endif
    return result;
}

int32 CAM_jpeg(void)
{
    int32 result = OS_SUCCESS;
    uint8_t  data[3];

    #ifdef OV2640
    result = arducam_i2c_write_regs(OV2640_JPEG);
    #endif
    #ifdef OV5640
    result = arducam_i2c_write_regs(OV5640_JPEG_QSXGA);
    result = arducam_i2c_write_regs(OV5640_QSXGA2QVGA);
    data[0] = 0x44;
    data[1] = 0x07;
    data[2] = 0x04;
    i2c_master_transaction(CAM_I2C, CAM_ADDR, &data, 3, NULL, 0, CAM_TIMEOUT);
    #endif
    #ifdef OV5642
    result = arducam_i2c_write_regs(ov5642_dvp_fmt_jpeg_qvga);
    #endif
    return result;
}

int32 CAM_setup(void)
{
    int32 result = OS_SUCCESS;
    uint8_t data[2];

    #ifdef OV2640
    // Change register set to camera
    data[0] = 0xFF; 
    data[1] = 0x01;
    i2c_master_transaction(CAM_I2C, CAM_ADDR, &data, 2, NULL, 0, CAM_TIMEOUT);
    // Common control 10
    data[0] = 0x15; 
    data[1] = 0x00;
    i2c_master_transaction(CAM_I2C, CAM_ADDR, &data, 2, NULL, 0, CAM_TIMEOUT);
    #endif
 
    return result;
}

int32 CAM_jpeg_320x240(void)
{
    int32 result = OS_SUCCESS;
    #ifdef OV2640
    result = arducam_i2c_write_regs(OV2640_320x240_JPEG);
    #endif
    #ifdef OV5640
    OS_TaskDelay(100);
    #endif
    #ifdef OV5642
    result = arducam_i2c_write_regs(ov5642_dvp_fmt_global_init);
    OS_TaskDelay(100);
    #endif
    return result;
}

int32 CAM_setSize(uint8_t size)
{
    int32 result = OS_ERROR;
    
    switch (size)
    {
        #ifdef OV2640
        case size_160x120:
            result = arducam_i2c_write_regs(OV2640_160x120_JPEG);
            break;
        case size_800x600:
            result = arducam_i2c_write_regs(OV2640_800x600_JPEG);
            break;
        case size_1600x1200:
            result = arducam_i2c_write_regs(OV2640_1600x1200_JPEG);
            break;
        default:
            result = arducam_i2c_write_regs(OV2640_160x120_JPEG);
            break;
        #endif
        #ifdef OV5640
        case size_320x240:
            result = arducam_i2c_write_regs(OV5640_QSXGA2QVGA);
            break;
        case size_1600x1200:
            result = arducam_i2c_write_regs(OV5640_QSXGA2UXGA);
            break;
        case size_2592x1944:
            result = arducam_i2c_write_regs(OV5640_JPEG_QSXGA);
            break;
        default:
            result = arducam_i2c_write_regs(OV5640_QSXGA2QVGA);
            break;
        #endif
        #ifdef OV5642
        case size_320x240:
            result = arducam_i2c_write_regs(ov5642_dvp_fmt_jpeg_qvga);
            break;
        case size_1600x1200:
            result = arducam_i2c_write_regs(ov5642_dvp_fmt_jpeg_qvga); // TODO: Add correct register
            break;
        case size_2592x1944:
            result = arducam_i2c_write_regs(ov5642_dvp_fmt_jpeg_5M);
            result = arducam_i2c_write_regs(ov5642_dvp_fmt_jpeg_qxga);
            CAM_setSize_OV5642();
            break;
        default:
            result = arducam_i2c_write_regs(ov5642_dvp_fmt_jpeg_qvga);
            break;
        #endif        
    }
    // Let auto exposure do it's thing
    OS_TaskDelay(1000);

    return result;
}

#ifdef OV5642
static int32 CAM_setSize_OV5642(void)
{
    int32 result = OS_SUCCESS;
    uint8_t  data[3];

    data[0] = 0x38; 
    data[1] = 0x18;
    data[2] = 0xA8;
    i2c_master_transaction(CAM_I2C, CAM_ADDR, &data, 3, NULL, 0, CAM_TIMEOUT);
    data[0] = 0x36; 
    data[1] = 0x21;
    data[2] = 0x10;
    i2c_master_transaction(CAM_I2C, CAM_ADDR, &data, 3, NULL, 0, CAM_TIMEOUT);
    data[0] = 0x38; 
    data[1] = 0x01;
    data[2] = 0xC8;
    i2c_master_transaction(CAM_I2C, CAM_ADDR, &data, 3, NULL, 0, CAM_TIMEOUT);

    return result;
}
#endif

int32 CAM_capture_prep(void)
{
    int32 result = OS_ERROR;
    uint8_t data[2];

    // Select chip
    result = spi_select_chip(&CAM_SPI);

    if (result == OS_SUCCESS)
    {   // Prepare for capture
        #if (defined(OV5640) || defined(OV5642))
        data[0] = 0x83;
        data[1] = 0x02;
        spi_write(&CAM_SPI, data, 2);  // VSYNC is active HIGH
        OS_TaskDelay(100);
        #endif
        data[0] = 0x84;
        data[1] = 0x01;
        spi_write(&CAM_SPI, data, 2);  // Flush the fifo
        OS_TaskDelay(100);
        data[0] = 0x84;
        data[1] = 0x01;
        spi_write(&CAM_SPI, data, 2);  // Clear capture done flag
        OS_TaskDelay(100);
        data[0] = 0x84;
        data[1] = 0x02;
        spi_write(&CAM_SPI, data, 2);  // Start capture
        OS_TaskDelay(100);

        // Unselect chip
        result = spi_unselect_chip(&CAM_SPI);
        if (result != OS_SUCCESS)
        {
            result = OS_ERROR;
        }
        else
        {
            result = OS_SUCCESS;
        }    
    }

    return result;
}

int32 CAM_capture(void)
{   
    uint8_t temp[2] = {0x00, 0x00};
    int32 result = OS_SUCCESS;
    int32 state  = OS_SUCCESS;
    uint16_t count = 0x0000;
    uint8_t data[2];
    
    // Select chip
    result = spi_select_chip(&CAM_SPI);

    if (result == OS_SUCCESS)
    {   // Wait for capture done
        data[0] = 0x41;
        data[1] = 0x00;
        spi_write(&CAM_SPI, data, 2);
        spi_read(&CAM_SPI, temp, 2);

        while ( !( ((temp[1] & 0xFF)) & CAP_DONE_MASK) )
        {   
            data[0] = 0x41;
            data[1] = 0x00;
            spi_write(&CAM_SPI, data, 2);
            spi_read(&CAM_SPI, temp, 2);
            count++;
            OS_TaskDelay(10);      // Let other processes run
            //OS_printf("CAM_capture: temp = 0x%04x \n", temp);
            if (count >= 0x0400)   // Magic number
            {
                state = OS_ERROR;
                break;
            }
        }

        // Unselect chip
        result = spi_unselect_chip(&CAM_SPI); 
        if (result != OS_SUCCESS)
        {
            state = OS_ERROR;
        }
    }
        
    return state;
}

int32 CAM_read_fifo_length(uint32* length)
{
    int32 result = OS_SUCCESS;
    int32 state = OS_SUCCESS;
    uint8_t temp[2] = {0x55, 0x55};
    uint8_t data[2];

    // Select chip
    result = spi_select_chip(&CAM_SPI);

    if (result == OS_SUCCESS)
    {   // Read FIFO Length 
        data[0] = 0x44;
        data[1] = 0x00;
        spi_write(&CAM_SPI, data, 2);
        spi_read(&CAM_SPI, temp, 2);  
        //OS_printf("CAM_read_fifo_length: temp = 0x%04x \n", temp);
        *length = (temp[1] & 0x00FF);
        data[0] = 0x43;
        data[1] = 0x00;
        spi_write(&CAM_SPI, data, 2);
        spi_read(&CAM_SPI, temp, 2);  
        //OS_printf("CAM_read_fifo_length: temp = 0x%04x \n", temp);
        *length = (*length << 16) | ((temp[1] & 0x00FF) << 8);
        data[0] = 0x42;
        data[1] = 0x00;
        spi_write(&CAM_SPI, data, 2);
        spi_read(&CAM_SPI, temp, 2);  
        //OS_printf("CAM_read_fifo_length: temp = 0x%04x \n", temp);
        data[0] = 0x42;
        data[1] = 0x00;
        spi_write(&CAM_SPI, data, 2);
        spi_read(&CAM_SPI, temp, 2);  
        //OS_printf("CAM_read_fifo_length: temp = 0x%04x \n", temp);
        *length = (*length | (temp[1] & 0x00FF)) & 0x007FFFFF;
        #ifdef STF1_DEBUG
            OS_printf("\n CAM FIFO Length = %d  = 0x%08x\n", (int) *length,  (int) *length);
        #endif

        if ((*length > MAX_FIFO_SIZE) || (*length == 0))
        {
            state = OS_ERROR;
            
            state = OS_SUCCESS; // DEBUG
        }

        // Unselect chip
        result = spi_unselect_chip(&CAM_SPI); 
        if (result != OS_SUCCESS)
        {
            state = OS_ERROR;
        }
    }

    return state; 
}

int32 CAM_read_prep(char* buf, uint16* i)
{
    // Local variables
    uint8_t temp[2] = {0x00, 0x00};
    int32 result = OS_SUCCESS;
    int32 state  = OS_SUCCESS;
    uint16_t count = 0x0000;
    uint8_t data[2] = { 0x00, 0x00};
    
    #ifdef FILE_OUTPUT
        remove("pic.jpg");
    #endif

    // Select chip
    result = spi_select_chip(&CAM_SPI);
    data[0] = 0xBD;
    data[1] = 0x00;
    spi_write(&CAM_SPI, data, 2);
    spi_read(&CAM_SPI, temp, 2);  

    if (result == OS_SUCCESS)
    {   // Read until JPEG header
        while (temp[1] != 0xFF)
        {  
            data[0] = 0x3D;
            data[1] = 0x00;
            spi_write(&CAM_SPI, data, 2);
            spi_read(&CAM_SPI, temp, 2);  
            //OS_printf("CAM_read_prep: temp = 0x%04x \n", temp);
            temp[1] = (temp[1] & 0xFF);

            count++;
            if (count > 500) // Magic Number
            {
                state = OS_ERROR;
                temp[1] = 0xFF;
            }
        }

        // Unselect chip
        result = spi_unselect_chip(&CAM_SPI);
        if (result != OS_SUCCESS)
        {
            state = OS_ERROR;
        }
        else
        {
            // Write first image data to buffer
            buf[(*i)++] = temp[1];
            result = OS_SUCCESS;
        }      
    }
     
    return state;
}

int32 CAM_read(char* buf, uint16* i, uint8* status)
{    
    // Local variables
    uint8_t temp[2] = { 0x00, 0x00};
    uint8_t temp_last[2] = { 0x00, 0xFF};
    int32 result = OS_SUCCESS;
    uint8_t spiw[2] = { 0x3D, 0x00}; // FIFO read
    
    #ifdef FILE_OUTPUT
        FILE *fp1 = fopen("pic.jpg", "a"); 
        if (!fp1)
        {
            OS_printf("\t ERROR: Could not create file\n");
        }
    #endif

    // Select chip
    result = spi_select_chip(&CAM_SPI);
  
    if (result == OS_SUCCESS)
    {   // Read JPEG data from FIFO
        while ( ( ((temp[1] != 0xD9) || (temp[0] != 0x00)) || ((temp_last[1] != 0xFF) || (temp_last[0] != 0x00)) )
                && (*i < CAM_DATA_SIZE) )
        {
            temp_last[0] = temp[0];
            temp_last[1] = temp[1];      
            spiw[0] = 0x3D;
            spiw[1] = 0x00;
            spi_write(&CAM_SPI, spiw, 2);
            spi_read(&CAM_SPI, temp, 2);  
            
            // Write image data to buffer
            temp[0] = (temp[0] & 0x00);
            temp[1] = (temp[1] & 0xFF);
            buf[(*i)++] = temp[1]; 
            
            if ( temp_last[0] == 0x00)
            {
                switch ( temp_last[1] )
                {   
                    case 0xFF:
                        if (temp[0] == 0x00)
                        {
                            switch ( temp[1] )
                            {   
                                case 0xD8:
                                    (*status)++;
                                    #ifdef STF1_DEBUG
                                        OS_printf("\n Start of image...\n");
                                    #endif
                                    break;
                                case 0xDA:
                                    (*status)++;
                                    #ifdef STF1_DEBUG
                                        OS_printf("\n Start of scan...\n");
                                    #endif
                                    break;
                                case 0xDB:
                                    (*status)++;
                                    #ifdef STF1_DEBUG
                                        OS_printf("\n Define quantization table(s)...\n");
                                    #endif
                                    break;
                                case 0xC4:
                                    (*status)++;
                                    #ifdef STF1_DEBUG
                                        OS_printf("\n Define huffman table(s)...\n");
                                    #endif
                                    break;
                                case 0xD3:
                                    (*status)++;
                                    #ifdef STF1_DEBUG
                                        OS_printf("\n What is that!?!? \n");
                                    #endif
                                    break;
                                case 0xD9:
                                    (*status)++;
                                    #ifdef STF1_DEBUG
                                        OS_printf("\n End of image...\n");
                                    #endif
                                    (*status) = OS_SUCCESS;
                                    spiw[0] = 0x84;
                                    spiw[0] = 0x01; // Clear the capture done flag
                                    spi_write(&CAM_SPI, spiw, 2);                     
                                    break;
                                default:
                                    break;
                            }
                        } // end if (temp[0] == 0x00)
                        break;
                    default:
                        break;
                }
            } // end if (temp_last[0] == 0x00)
        }

        // Unselect chip
        result = spi_unselect_chip(&CAM_SPI);
        if (result != OS_SUCCESS)
        {
            result = OS_ERROR;
        }
        else
        {
            result = OS_SUCCESS;
        }     
    }
    
    
    // Write the buffer to a file
    #ifdef FILE_OUTPUT
        fwrite(buf, *i, 1, fp1); 
        fclose(fp1);            
    #endif
    
    return result;
}

static int32 arducam_i2c_write_regs(struct sensor_reg reglist[])
{   
    int32 result = OS_SUCCESS;
    struct sensor_reg *next = reglist;
    #ifdef OV2640
    uint8 test[2];
    #endif
    #if (defined(OV5640) || defined(OV5642))
    uint8 test[3];
    #endif
    int32 errors = 0;

    #ifdef OV2640
    while ((next->reg != 0xFF) || (next->val != 0xFF))
    {
        test[0] = next->reg; 
        test[1] = next->val;
        result = i2c_master_transaction(CAM_I2C, CAM_ADDR, &test, 2, NULL, 0, CAM_TIMEOUT);
        OS_TaskDelay(1);  // Let other processes run
        if (result != -1) // OS_SUCCESS
        {
            errors++;
        }

        // Check that register was written properly
        /*
        test[2] = 0xFF;
        result = i2c_master_transaction(CAM_I2C, CAM_ADDR, &test, 2, &test[2], 1, CAM_TIMEOUT);
        if (test[2] != next->val)
        {
            OS_printf("----- arducam_i2c_write_regs: error on config check \n");
        }
        */
        next++;
    }
    #endif
    #if (defined(OV5640) || defined(OV5642))
    while ((next->reg != 0xFFFF) || (next->val != 0xFF))
    {
        test[0] = (next->reg & 0xFF00) >> 8;
        test[1] = next->reg & 0x00FF;
        test[2] = next->val;

        //OS_printf("test[0] = 0x%02x; test[1] = 0x%02x; test[2] = 0x%02x; \n", test[0],test[1],test[2]);

        result = i2c_master_transaction(CAM_I2C, CAM_ADDR, &test, 3, NULL, 0, CAM_TIMEOUT);
        OS_TaskDelay(1);  // Let other processes run
        if (result != OS_SUCCESS) 
        {
            errors++;
        }

        // Check that register was written properly
        /*
        test[2] = 0xFF;
        result = i2c_master_transaction(CAM_I2C, CAM_ADDR, &test, 2, &test[2], 1, CAM_TIMEOUT);
        if (test[2] != next->val)
        {
            OS_printf("----- arducam_i2c_write_regs: error on config check \n");
        }
        */
        next++;
    }
    #endif

    #ifdef STF1_DEBUG
        if (errors > 0)
        {
            OS_printf("CAM_LIB: arducam_i2c_write_regs had %ld errors!", errors);
        }
    #endif  

    // Change to preferred OS_SUCCESS
    if (errors <= 10)   
    {
        result = OS_SUCCESS;
    }
    else
    {
        result = OS_ERROR;
    }
    return result;
}
